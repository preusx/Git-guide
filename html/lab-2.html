<!DOCTYPE  html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>doc</title>
    <style>
      /*github.com style (c) Vasily Polovnyov <vast@whiteants.net>*/
      pre code {
        display: block; padding: 0.5em;
        color: #333;
        background: #f8f8ff
      }
      pre .comment,
      pre .template_comment,
      pre .diff .header,
      pre .javadoc {
        color: #998;
        font-style: italic
      }
      pre .keyword,
      pre .css .rule .keyword,
      pre .winutils,
      pre .javascript .title,
      pre .nginx .title,
      pre .subst,
      pre .request,
      pre .status {
        color: #333;
        font-weight: bold
      }
      pre .number,
      pre .hexcolor,
      pre .ruby .constant {
        color: #099;
      }
      pre .string,
      pre .tag .value,
      pre .phpdoc,
      pre .tex .formula {
        color: #d14
      }
      pre .title,
      pre .id {
        color: #900;
        font-weight: bold
      }
      pre .javascript .title,
      pre .lisp .title,
      pre .clojure .title,
      pre .subst {
        font-weight: normal
      }
      pre .class .title,
      pre .haskell .type,
      pre .vhdl .literal,
      pre .tex .command {
        color: #458;
        font-weight: bold
      }
      pre .tag,
      pre .tag .title,
      pre .rules .property,
      pre .django .tag .keyword {
        color: #000080;
        font-weight: normal
      }
      pre .attribute,
      pre .variable,
      pre .lisp .body {
        color: #008080
      }
      pre .regexp {
        color: #009926
      }
      pre .class {
        color: #458;
        font-weight: bold
      }
      pre .symbol,
      pre .ruby .symbol .string,
      pre .lisp .keyword,
      pre .tex .special,
      pre .prompt {
        color: #990073
      }
      pre .built_in,
      pre .lisp .title,
      pre .clojure .built_in {
        color: #0086b3
      }
      pre .preprocessor,
      pre .pi,
      pre .doctype,
      pre .shebang,
      pre .cdata {
        color: #999;
        font-weight: bold
      }
      pre .deletion {
        background: #fdd
      }
      pre .addition {
        background: #dfd
      }
      pre .diff .change {
        background: #0086b3
      }
      pre .chunk {
        color: #aaa
      }
    </style>
  </head>
  <body>  
    <h3 id="-">Лабораторная работа</h3>
<h1 id="-git-git-">Введение в системы контроля версий. Git. Работа с локальным репозиторием. Внешние сервера Git и работа с ними.</h1>
<h3 id="-">Теоретическая часть</h3>
<h4 id="-commit-">Запись изменений в репозиторий(commit).</h4>
<p>Итак, у вас имеется настоящий Git-репозиторий и рабочая копия файлов для некоторого проекта. Вам нужно делать некоторые изменения и фиксировать “снимки” состояния (snapshots) этих изменений в вашем репозитории каждый раз, когда проект достигает состояния, которое вам хотелось бы сохранить.</p>
<p>Как только вы отредактируете файлы, Git будет рассматривать их как изменённые, т.к. вы изменили их с момента последнего коммита. Вы индексируете (stage) эти изменения и затем фиксируете все индексированные изменения, а затем цикл повторяется.</p>
<p>Когда вы создаёте коммит в Git&#39;е, Git записывает в базу объект-коммит, который содержит указатель на снимок состояния, записанный ранее в индекс, метаданные автора и комментария и ноль и более указателей на коммиты, являющиеся прямыми предками этого коммита: ноль предков для первого коммита, один — для обычного коммита и несколько — для коммита, полученного в результате слияния двух или более веток. Таким образом, Git сможет воссоздать текущее состояние, когда будет нужно.</p>
<h4 id="-">Что такое ветка?</h4>
<p>Чтобы на самом деле разобраться в том, как Git работает с ветками, мы должны сделать шаг назад и рассмотреть, как Git хранит свои данные. Git хранит данные как последовательность снимков состояния.</p>
<p>Ветка в Git&#39;е — это просто легковесный подвижный указатель на один из этих коммитов. Ветка по умолчанию в Git&#39;е называется master. Когда вы создаёте коммиты на начальном этапе, вам дана ветка master, указывающая на последний сделанный коммит. При каждом новом коммите она сдвигается вперёд автоматически.</p>
<p>Из-за того, что ветка в Git&#39;е на самом деле является простым файлом, который содержит 40 символов контрольной суммы SHA-1 коммита, на который он указывает, создание и удаление веток практически беззатратно. Создание новой ветки настолько же быстрое и простое, как запись 41 байта в файл (40 символов + символ новой строки).</p>
<h5 id="-">Долгоживущие ветки</h5>
<p>Так как Git использует простое трёхходовое слияние, периодически сливать одну ветку с другой на протяжении большого промежутка времени достаточно просто. Это значит, вы можете иметь несколько веток, которые всегда открыты и которые вы используете для разных стадий вашего цикла разработки; вы можете регулярно сливать их одну в другую.</p>
<p>Многие разработчики Git&#39;а придерживаются такого подхода, при котором ветка master содержит исключительно стабильный код — единственный выпускаемый код. Для разработки и тестирования используется параллельная ветка, называемая develop или next, она может не быть стабильной постоянно, но в стабильные моменты её можно слить в master. Эта ветка используется для объединения завершённых задач из тематических веток, чтобы удостовериться, что эти изменения проходят все тесты и не вызывают ошибок.</p>
<h5 id="-">Тематические ветки</h5>
<p>Тематические ветки, однако, полезны в проектах любого размера. Тематическая ветка — недолговечная ветка, которую вы создаёте и используете для работы над некоторой отдельной функциональностью или для вспомогательной работы.</p>
<p>Такая техника позволяет быстро и полноценно переключать контекст. Ибо когда все изменения разбиты по веткам и определённым темам, намного проще понять, что было сделано, во время проверки и просмотра кода. Вы можете сохранить там изменения на несколько минут, дней или месяцев, а затем, когда они готовы, слить их в основную ветку, независимо от порядка, в котором их создавали или работали над ними.</p>
<h3 id="-">Практическая часть</h3>
<h4 id="-git-">Добавление начальной информации в Git репозиторий.</h4>
<ul>
<li>Создадим чистый файл README.md. Для первого коммита в репозиторий можно добавить уже существующий код.</li>
<li>Теперь кликаем правой кнопкой на папке проекта, на папке &quot;.git&quot; в корне проекта(она обычно скрыта), или на пустом месте в папке проекта. И в контекстном меню выбираем &#39;Git commit -&gt; &quot;master&quot;&#39;.</li>
<li>Появится окно с деталями коммита:</li>
</ul>
<p><img src="../img/tortoise/3.png" alt=""></p>
<ul>
<li>Текстовое поле &quot;Message&quot; предназначено для краткого описания изменений, которые затрагивает этот коммит.</li>
<li>Область &quot;Changes made:&quot; - выбор файлов которые затрагивает текущий коммит. В данном случае я добавил один файл.</li>
</ul>
<p>Теперь у нас есть цельный репозиторий с файлами в нем.</p>
<h4 id="-git-">Изменение в Git репозитории.</h4>
<p>Теперь вы можете измененять, добавлять или удалять какой-нибудь файл в репозиртории. Рекомендуется делать это как можно чаще, но только в том случае, если ваши изменения являются цельными, и явно не нарушают работу проекта.</p>
<h4 id="-branching-">Ветвление(branching).</h4>
<p>Во время написания чего-либо будь то книга, курсовая, проект на досуге, или работа над проектом в команде часто бывает необходимо добавить новую информацию, функционал, или переписать существующую часть при этом не нарушая целосности проекта. Для таких случаев пользуют ветвления.</p>
<ul>
<li>Для создания ветки в конекстном меню TortoiseGit текущего проекта есть комманда &quot;Create branch&quot;.</li>
<li>Окно создания веткивыглядит следующим образом:</li>
</ul>
<p><img src="../img/tortoise/4.png" alt=""></p>
<ul>
<li>Первое поле - низвание нашей новой ветки.</li>
<li>Область &quot;Base on&quot; говорит нам что предназначена для выбора ветки, тега или коммита(тоесть снимка, коим является ветка, коммит, или тег), на котором будет основываться наша новая ветвь.</li>
<li>Опции:<ul>
<li>Force - Вне зависимости от ошибок, которые могут случиться создать новую ветку.</li>
<li>Switch to new branch - Сразу после создания переключиться на новую ветку.</li>
</ul>
</li>
</ul>
<p>Итак - называем новую ветку, и жмем Ок.</p>
<p>Ветка создана. Для того что-бы перейти на другую ветвь необходимо выполнить комманду &quot;Switch/Checkout&quot; из конекстного меню TortoiseGit и в появившемся окне бырать коммит, ветку или тег на которые вы хотите перейти. Но пока мы этого делать не будем. А создадим еще один файл, и &quot;закоммитим&quot; изменения.</p>
<p>Теперь при переходе на master ветку этот файл изчезнет. Это значит что изменения в нашей новой ветке не отразились на основной. В данном контексте перспективы использования данного функуионала могут показатся излишними. Но при разработке более крупных проектов подобные возможности очень сильно помогают сохранять организованность кода. Рассмотрим пример:</p>
<p>Вы создаете небольшую программу. Основной функционал уже готов, и она неплохо справляется со своими &quot;обязанностями&quot;, но через некоторое время понадобилось некоторое изменение в ее работе. Есть два варианта развития событий: вы создаете ветку и начинаете разработку нового функционала в ней, или продолжаете работать в основной ветке.
Новая вводная и этот функционал вам уже не нужен, а появилась потребность в другой &quot;фиче&quot;(англ. feature - особенность, черта).
Если вы вели разработку в отдельной ветке, то никаких проблем не будет, вы просто перейдете в основную ветку, отпочкуетесь опять и спокойно будете работать. Во втором-же случае нужно будет откатывать изменения в главной ветке. Естественно, вы можете предварительно отпочковать текущие изменения и проблема тоже решена, но при еще нескольких вводных решение подобных проблем будут становиться все дольше и проблематичней, что делает ветки очень удобным инструментом систем контроля версий.</p>
<p>Для обьединения веток существует еще один инструмент, который называется слияния.</p>
<h4 id="-merging-">Слияния(merging).</h4>
<ul>
<li>Для слияния веток в конекстном меню TortoiseGit текущего проекта есть комманда &quot;Merge&quot;.</li>
<li>Если, на пример, вы хотите чтобы изменения, которые вы зделали в ветке <code>issue-45</code> попали в <code>master</code>, нужно перейти в <code>master</code> и мержить из нее.</li>
<li>Окно создания ветки выглядит следующим образом:</li>
</ul>
<p><img src="../img/tortoise/5.png" alt=""></p>
<ul>
<li>Первое поле предназначено для выбора указателя(ветки, коммита..) изменения которого будете &quot;вливать&quot; в текущую ветку.</li>
<li>Также, если есть потребность, можно описать это слияние. Но в большинстве случаев автоматически генерируемоего собщения достаточно.</li>
</ul>
<h4 id="git-">Git на сервере</h4>
<p>К этому моменту вы уже должны уметь решать большинство повседневных задач, для которых будете использовать Git. Однако, для совместной работы в Git&#39;е, вам необходим удалённый репозиторий. Несмотря на то, что технически вы можете отправлять и забирать изменения непосредственно из личных репозиториев, делать это не рекомендуется. Вы легко можете испортить то, над чем работают другие, если не будете аккуратны. К тому же, вам бы наверняка хотелось, чтобы остальные имели доступ к репозиторию даже если ваш компьютер выключен, поэтому наличие более надежного репозитория обычно весьма полезно. Поэтому предпочтительный метод взаимодействия с кем-либо — это создание промежуточного репозитория, к которому вы оба будете иметь доступ, и отправка и получение изменений через него.</p>
<p>Если вы не хотите связываться со всей работой по установке собственного Git-сервера, у вас есть несколько вариантов размещения ваших Git-проектов на внешних специальных хостинг сайтах. Это предоставляет множество преимуществ: на хостинг сайте обычно быстро настроить и запустить проект и нет никакого мониторинга или поддержки сервера. Даже если вы установили и запустили свой собственный внутренний сервер, вы можете захотеть использовать публичный хостинг сайт для вашего открытого кода — обычно сообществу открытого кода так будет проще вас найти и помочь.</p>
<p>В наши дни у вас есть огромное количество вариантов хостинга на выбор, все со своими преимуществами и недостатками. Актуальный список можно найти на следующей странице:</p>
<p><a href="https://git.wiki.kernel.org/index.php/GitHosting"><a href="https://git.wiki.kernel.org/index.php/GitHosting">https://git.wiki.kernel.org/index.php/GitHosting</a></a></p>
<p>Поскольку мы не можем рассмотреть их все мы в этом разделе рассмотрим процесс создания учётной записи и нового проекта на GitHub&#39;е. Если у вас есть потребность в закрытых репозиториях(бесплатно, но с ограничениями, в отличии от платного GitHub) - замечательной альтернативой GitHub является <a href="https://bitbucket.org">Bitbucket</a>.</p>
<p>GitHub — крупнейший на сегодняшний день сайт, предоставляющий Git-хостинг для проектов с открытым исходным кодом, а также один из немногих, предоставляющих одновременно и публичный, и приватный хостинг, так что вы можете хранить ваш открытый и коммерческий код в одном месте.</p>
<p>Первое, что вам нужно сделать, это настроить учётную запись. Регистрация ничем не отличается от регистрации на других интернет ресурсах, та что эта часть освещаться не будет.</p>
<h4 id="-darr-">На этом все. Всем всего. Проверьте себя ответив на контрольные вопросы ниже&darr; и если все в порядке - бегом делать следующую лабку.</h4>
<h3 id="-">Контрольные вопросы</h3>
<p>1.</p>

  </body>
</html>
